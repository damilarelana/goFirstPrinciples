package main

import (
	"crypto/sha1"
	"encoding/base64"
	"fmt"
	"hash/crc32"
	"io/ioutil"
	"reflect"
	"strconv"
)

func leNormalHasher(filename string) (uint32, error) {
	fileBytes, err := ioutil.ReadFile(filename) // read the file to be hashed
	if err != nil {
		return 0, err // return a Hash of value 0 i.e. no logical file was read or hashed or no reason to continue attempt to hash
	}

	// initialize a new Hasher
	newHasher := crc32.NewIEEE()  // newinstance of the NewIEEE hasher
	newHasher.Write(fileBytes)    // call newHasher's write interface AND pass the fileBytes i.e. BEFORE we use the hasher to do something with the byte
	return newHasher.Sum32(), nil // finally call the hashing method Sum32() and return the value [and nil for error]
}

func leCryptoHasher(filename string) ([]byte, error) {
	fileBytes, err := ioutil.ReadFile(filename) // read the file to be hashed
	if err != nil {
		return []byte{}, err // return a Hash of value empty byte slice ([]byte)  i.e. no logical file was read or hashed or no reason to continue attempt to hash
	}

	// initialize a new Hasher
	newHasher := sha1.New()             // newinstance of the SHA1 hasher
	newHasher.Write(fileBytes)          // call newHasher's write interface AND pass fileBytes i.e. BEFORE we use the hasher to do something with byte
	return newHasher.Sum([]byte{}), nil // finally call/return value generated by Sum(), and also return nil for error
	// []byte{} is used as an argument to Sum() because Sum() "automagically" appends the hash value to the empty slice of bytes
	// i.e. the []byte{} itself is not the data
	// see definition of the Hash interface https://golang.org/pkg/hash/#Hash

	//yes the ".Write" method is valid because it is part of the methodset created by sha1.New()
}

func main() {
	// implement both hasher and compare their outputs
	normalHashValue, err := leNormalHasher("../testData/testToHash.txt")
	if err != nil {
		return
	}
	normalHashStringValue := strconv.FormatUint(uint64(normalHashValue), 10) // this converts the hashvalue to the normal publically known string version
	// base64.URLEncoding.EncodeToString() is not used as it only take []byte argument and not uint32 as we have in this case
	// also strconv only allows uint64, as such we have to cast normalHashValue from uint32 to uint64 also

	cryptoHashValue, err := leCryptoHasher("../testData/testToHash.txt")
	if err != nil {
		return
	}
	cryptoHashStringValue := base64.URLEncoding.EncodeToString(cryptoHashValue) // this converts the hashvalue to the normal publically known string version

	// Print the hashvalue and compare if both has value are the same
	fmt.Println("==== Generated Hash Values ====")
	fmt.Println("normal generated hash:", normalHashValue)
	fmt.Println("crypto generated hash:", cryptoHashValue) // this prints the slice of bytes format for the SHA1 hash

	fmt.Println(" ")
	fmt.Println("==== ====")
	fmt.Println("normal public hash:", normalHashStringValue)
	fmt.Println("crypto public hash:", cryptoHashStringValue) // this prints the slice of bytes format for the SHA1 hash

	// fmt.Printf("%x\n", cryptoHashValue) // this prints the normal SHA1 format you are aware of, for the SHA1 hash
	fmt.Println(" ")
	fmt.Println("==== Comparing Has Values ====")
	fmt.Println("Are both hash values the same:", reflect.DeepEqual(normalHashStringValue, cryptoHashStringValue))
}
